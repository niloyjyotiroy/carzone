#huffman
#include<bits/stdc++.h>

using namespace std;

main()
{
    int n;
    cout<<"Enter number of symbols n = ";
    cin>>n;
    int symbl_len;
    pair<double, string> records[n];
    priority_queue<pair<double, string> >pq;

    cout<<"Enter symbol - probability pair"<<endl;
    for(int i=0; i<n; i++)
    {
        string symbol;
        double probability;
        cin>>symbol>>probability;
        records[i]={-probability, symbol};
        pq.push(records[i]);
        symbl_len=symbol.length();
    }
    stack<pair<string, string> > st;
    while(!pq.empty())
    {
        pair<double, string> left = pq.top();
        pq.pop();
        if(pq.empty())
        {
            break;
        }
        pair<double, string> right = pq.top();
        pq.pop();

        string common=left.second+right.second;
        double total=left.first+right.first;
        pq.push({total, common});
        st.push({left.second, right.second});

    }

    map<string, string> code;
    while(!st.empty())
    {
        pair<string, string> common=st.top();
        st.pop();
        string left = common.first, right = common.second;
        for(int i=0; i<left.length(); i+=symbl_len)
        {
            string ch="";
            for(int j=i; j<i+symbl_len; j++)
            {
                ch+=left[j];
            }
            code[ch]=code[ch]+"0";
        }
        for(int i=0; i<right.length(); i+=symbl_len)
        {
            string ch="";
            for(int j=i; j<i+symbl_len; j++)
            {
                ch+=right[j];
            }
            code[ch]=code[ch]+"1";
        }
    }
    cout<<"Huffman code for those given symbols are given bellow."<<endl;
    for(auto it:code)
    {
        cout<<it.first<<" --> "<<it.second<<endl;
        cout<<"---------------------------"<<endl;
    }
}

#convolution code

#include<bits/stdc++.h>

using namespace std;

vector<int>generate_g(string G){
    vector<int>g;
    for(int i = 0; i < G.length(); i++)
    {
        if(G[i]=='1')
        {
            g.push_back(i);
        }
    }
    return g;
}

vector<int> multiply(vector<int> g, vector<int> m)
{
    vector<int>y;
    for(int i = 0; i < g.size(); i++)
    {
        for(int j = 0; j < m.size(); j++)
        {
            y.push_back(g[i]+m[j]);
        }
    }
    return y;
}

void printv(vector<int>v)
{
    for(int i=0; i<v.size(); i++)
    {
        cout<<v[i]<<" ";
    }
    cout<<endl;
}

main(){
    string G2 = "101", G1 = "111";
    string message;
    cout<<"Enter the message bit sequence : ";
    cin>>message;

    vector<int>g1, g2, m;

    int i=0;
    g1 = generate_g(G1);
    g2 = generate_g(G2);
    m = generate_g(message);

    vector<int>y1, y2;
    y1 = multiply(g1, m);
    y2 = multiply(g2, m);

    sort(y1.begin(), y1.end());
    sort(y2.begin(), y2.end());

    cout<<"Y1 = ";
    printv(y1);
    cout<<"Y2 = ";
    printv(y2);

    int mexlen = max(*(y1.end()-1), *(y2.end()-1));

    int code1[mexlen+1] , code2[mexlen+1];
    memset(code1, 0, sizeof(code1));
    memset(code2, 0, sizeof(code2));
    for(i=0; i<y1.size(); i++)
    {
        code1[y1[i]]^=1;
    }
    for(i=0; i<y2.size(); i++)
    {
        code2[y2[i]]^=1;
    }
    for(int i=0; i<=mexlen; i++)
    {
        cout<<code1[i]<<code2[i]<<" ";
    }
    cout<<endl;
}

#updated hamming code

#include<bits/stdc++.h>
using namespace std;

int main()
{
    string s;
    cout<<"Enter the given sequence - ";
    cin>>s;
    int n=s.size();

    // step 1: koyta hamming bit lagbe
    int total_parity=0;
    for(int i=1; i<n; i++){
        if(pow(2, i) >= n+i+1){
            total_parity=i;
            break;
        }
    }

	// step 2: hamming bit gula koi koi bosbe
    vector<int>pows;
    for(int i=0; i<total_parity; i++){
        pows.push_back(pow(2,i));
    }

    // step 3: hamming bit er position bad dia bakigula bosailam
    int ans[n+total_parity+1]={}, j=n-1;
    for(int i=1; i<=n+total_parity and j>=0; i++){
        if( !count(pows.begin(), pows.end(), i) ){
            ans[i] = (s[j]=='0' ? 0:1);
            j--;
        }
    }

	// stp 4: calculating hamming bits
    cout<<"Here,"<<endl;
    for(int i=0; i<pows.size(); i++){
		// full array er jesob index er i-th bit 1 oigulate gunbo 1 ache kina
		int parity=0;
    	for(int j=1; j<=n+total_parity; j++){
    		if( j&(1<<i) ){
    			parity ^= ans[j]; // xor diye even parity er kaaj kora hocche
    		}
    	}
    	cout<<"H"<<i<<" = "<<parity<<endl;
    	ans[pows[i]] = parity;
    }

    cout<<"Final output is : ";
    for(int i=n+total_parity; i>0; i--){
        cout<<ans[i]<<" ";
    }
    cout<<endl;

    //For decoding[detection of the error bit]
    cout<<"For changing one bit, select an index[form right]: ";
    int index;
    cin>>index;
    if(ans[index]==1) ans[index] = 0;
    else ans[index] = 1;

    cout<<"After changing the bit: ";
    for(int i=n+total_parity; i>0; i--){
        cout<<ans[i]<<" ";
    }
    cout<<endl;

	// calculating D0,D1,D2...
	vector<int>D;
    cout<<"Here,"<<endl;
    for(int i=0; i<total_parity; i++){
		// full array er jesob index er i-th bit 1 oigulate gunbo 1 ache kina
		int parity=0;
    	for(int j=1; j<=n+total_parity; j++){
    		if( j&(1<<i) ){
    			parity ^= ans[j]; // xor diye even parity er kaaj kora hocche
    		}
    	}
    	cout<<"D"<<i<<" = "<<parity<<endl;
    	D.push_back(parity);
    }

    //D er value gula dia binary deciaml kora
    int errorIndex=1;
    bool start=0;
    for(int i=D.size()-1, j=0; i>=0; i--){
    	if(D[i]==1) start=1;

    	if(start==1) {
    		errorIndex += D[i] * pow(2,j);
    		j++;
    	}
    }
    cout<<"Error happend in the index no: "<<errorIndex<<endl;
}

#hamming code

#include <bits/stdc++.h>

unsigned int number_of_parity_bits(unsigned int n) {
	unsigned int p = 1;
	while(!(pow(2, p) >= (n + p + 1))) p++;
	return p;
}
bool powerOfTwo(int n) {
    return n && (!(n & (n-1)));
}

int main() {
	std::string s;
	std::cin >> s;
	unsigned int n = s.size(), p = number_of_parity_bits(n), sum = 0;
	unsigned long int N = std::bitset<32>(s).to_ulong(), mask = 1;	
	std::bitset<16> hamming_code;	
	
	for(int i=1; i<=p; i++) {
		sum = 0;
		for(int j=1, k=0; j<=(n+p); j++) {
			if(!powerOfTwo(j)) {
				sum = ((j & (mask << (i-1))) && (N & (mask << k))) ? (sum + 1) : sum;
				if(i==1 && (N & (mask << k))) hamming_code |= (mask << (j-1));
				k++;
			}
		}
		if(sum & mask) hamming_code |= (mask << ((int)pow(2, i-1) - 1));
	}
	std::cout << hamming_code << std::endl;
	return 0;
}

#lempel

#include<bits/stdc++.h>

using namespace std;


main()
{
    int n;
    string sequence;
    cout<<"Enter the binary sequence : ";
    cin>>sequence;

    n=sequence.length();

    map<string, int>mp;
    vector<pair<int, int> >p;
    vector<pair<int, string> >q;

    mp["0"]=1;
    mp["1"]=2;
    p.push_back({1, 0});
    p.push_back({2, 1});

    int j=3;

    for(int i=0; i<n; i)
    {
        string st="";
        st+=sequence[i];
        i++;
        int prefix=mp[st];
        while(mp[st] and i<n)
        {
            st+=sequence[i];
            i++;
            if(mp[st])
            {
                prefix=mp[st];
            }
        }
        if(i<=n and !mp[st]){
            mp[st]=j;
            prefix*=2;
            if(sequence[i-1]=='1')
                prefix+=1;
            p.push_back({j, prefix});
            j++;
        }
    }
    int mex_len=0;
    for(auto it:mp)
    {
        q.push_back({it.second, it.first});
        //cout<<it.first<<" "<<it.second<<endl;
        int x=it.first.length();
        mex_len=max(mex_len, x);
    }
    sort(p.begin(), p.end());
    sort(q.begin(), q.end());


    cout<<p[0].first<<" ---> "<<q[0].second<<endl;
    cout<<p[1].first<<" ---> "<<q[0].second<<endl;
    for(int i=2; i<p.size(); i++)
    {
        cout<<p[i].first<<" ---> "<<q[i].second<<" ---> "<<bitset<4>(p[i].second)<<endl;
    }
}

